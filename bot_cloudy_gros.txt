import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import time
import json
import os
from xapi.client import Client
from xapi.streaming import Streaming
from dotenv import load_dotenv
import logging

# Configuration de base du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')
logger = logging.getLogger('trading_bot')

# Importer google.cloud.logging seulement si n√©cessaire
try:
    import google.cloud.logging
    client = google.cloud.logging.Client()
    client.setup_logging()
except:
    pass

load_dotenv()  # Charger les variables d'environnement
    
class XTBTradingBot:
    def __init__(self, symbol='BITCOIN', timeframe='1h'):
        load_dotenv()  # Recharger les variables d'environnement
        self.userId = os.getenv('XTB_USER_ID')
        self.password = os.getenv('XTB_PASSWORD')
        if not self.userId or not self.password:
            raise ValueError("XTB_USER_ID et XTB_PASSWORD doivent √™tre d√©finis dans .env")
        self.symbol = symbol
        self.timeframe = timeframe
        self.client = None
        self.streaming = None
        self.position_open = False
        self.current_order_id = None
        self.last_reconnect = time.time()
        self.reconnect_interval = 60
        self.min_volume = 0.01
        self.risk_percentage = 0.01

    def connect(self):
        try:
            logging.info(f"üîÑ Tentative de connexion √† XTB - UserID: {self.userId}")
            self.client = Client()
            self.client.connect()
            response = self.client.login(self.userId, self.password)
            
            if response.get('status') == True:
                self.streaming = Streaming(self.client)
                logging.info("‚úÖ Connect√© √† XTB avec succ√®s")
                logging.info(f"D√©tails de la r√©ponse: {response}")
                self.last_reconnect = time.time()
                self.check_account_status()
                return True
            else:
                logging.error(f"‚ùå √âchec de connexion - D√©tails: {response}")
                return False
        except Exception as e:
            logging.error(f"‚ùå Erreur de connexion: {str(e)}")
            return False

    def check_connection(self):
        try:
            if self.client is None:
                logging.info("üîÑ Client est None, tentative de connexion...")
                return self.connect()
            
            ping_cmd = {
                "command": "ping"
            }
            response = self.client.commandExecute(ping_cmd["command"])
            logging.info(f"üèì Ping response: {response}")
            
            if response and response.get('status'):
                logging.info("‚úÖ Connexion active")
                return True
            else:
                logging.warning("‚ö†Ô∏è Connexion perdue, tentative de reconnexion...")
                return self.connect()
                
        except Exception as e:
            logging.error(f"‚ùå Erreur de v√©rification de connexion: {str(e)}")
            return False

    def check_account_status(self):
        try:
            if not self.check_connection():
                return None

            cmd = {
                "command": "getMarginLevel",
                "arguments": {}
            }
            response = self.client.commandExecute(cmd["command"], cmd["arguments"])
            if response and 'returnData' in response:
                margin_data = response['returnData']
                log_msg = f"üìä √âtat du compte - Balance: {margin_data.get('balance', 0)}, Equity: {margin_data.get('equity', 0)}, Margin Free: {margin_data.get('margin_free', 0)}"
                logging.info(log_msg)
                return margin_data
            return None
        except Exception as e:
            logging.error(f"‚ùå Erreur lors de la v√©rification du compte: {str(e)}")
            return None

    def calculate_position_size(self, entry_price, stop_loss):
        try:
            account_info = self.check_account_status()
            if not account_info:
                return self.min_volume
            
            balance = account_info.get('balance', 0)
            risk_amount = balance * self.risk_percentage
            pip_risk = abs(entry_price - stop_loss)
            
            if pip_risk == 0:
                return self.min_volume
                
            position_size = risk_amount / pip_risk
            position_size = max(position_size, self.min_volume)
            position_size = round(position_size, 2)
            
            logging.info(f"üìà Calcul du volume - Balance: {balance}, Risk amount: {risk_amount}, Position size: {position_size}")
            
            return position_size
            
        except Exception as e:
            logging.error(f"‚ùå Erreur dans le calcul du volume: {str(e)}")
            return self.min_volume

    def calculate_atr(self, df, period=14):
        try:
            if df is None or len(df) < period:
                return 0.001
                
            df = df.copy()
            df['high'] = pd.to_numeric(df['high'])
            df['low'] = pd.to_numeric(df['low'])
            df['close'] = pd.to_numeric(df['close'])
            
            df['tr1'] = abs(df['high'] - df['low'])
            df['tr2'] = abs(df['high'] - df['close'].shift())
            df['tr3'] = abs(df['low'] - df['close'].shift())
            
            df['tr'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)
            return df['tr'].rolling(period).mean().iloc[-1]
            
        except Exception as e:
            logging.error(f"‚ùå Erreur dans le calcul de l'ATR: {str(e)}")
            return 0.001

    def check_trade_execution(self, response):
        try:
            if not response.get('status'):
                return False
                
            order_id = response.get('returnData', {}).get('order')
            if not order_id:
                return False
                
            time.sleep(1)
            
            cmd = {
                "command": "tradeTransactionStatus",
                "arguments": {
                    "order": order_id
                }
            }
            status_response = self.client.commandExecute(cmd["command"], cmd["arguments"])
            
            return bool(status_response and status_response.get('returnData', {}).get('requestStatus') == 3)
            
        except Exception as e:
            logging.error(f"‚ùå Erreur lors de la v√©rification de l'ex√©cution: {str(e)}")
            return False

    def get_historical_data(self, limit=100):
        try:
            if not self.check_connection():
                return None

            period_start = int(time.time()) - (limit * 3600)
            
            command = {
                'command': 'getChartLastRequest',
                'arguments': {
                    'info': {
                        'symbol': self.symbol,
                        'period': 1,
                        'start': period_start * 1000,
                    }
                }
            }
            
            response = self.client.commandExecute(command["command"], command["arguments"])
            
            if isinstance(response, dict) and 'returnData' in response:
                data = response['returnData']
                if 'rateInfos' in data and len(data['rateInfos']) > 0:
                    df = pd.DataFrame(data['rateInfos'])
                    df['timestamp'] = pd.to_datetime(df['ctm'], unit='ms')
                    return df.sort_values('timestamp')
            return None
                    
        except Exception as e:
            logging.error(f"‚ùå Erreur dans get_historical_data: {str(e)}")
            return None

    def calculate_indicators(self, df):
        try:
            df = df.copy()
            df['SMA20'] = df['close'].rolling(window=20).mean()
            df['SMA50'] = df['close'].rolling(window=50).mean()
            
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['RSI'] = 100 - (100 / (1 + rs))
            
            return df
        except Exception as e:
            logging.error(f"‚ùå Erreur lors du calcul des indicateurs: {str(e)}")
            return None

    def check_trading_signals(self, df):
        if len(df) < 50:
            return None
            
        last_row = df.iloc[-1]
        
        buy_signal = (
            last_row['SMA20'] > last_row['SMA50'] and
            last_row['RSI'] < 70 and
            last_row['close'] > last_row['SMA20']
        )
        
        sell_signal = (
            last_row['SMA20'] < last_row['SMA50'] and
            last_row['RSI'] > 30 and
            last_row['close'] < last_row['SMA20']
        )
        
        logging.info(f"üîç Analyse - SMA20: {last_row['SMA20']}, SMA50: {last_row['SMA50']}, RSI: {last_row['RSI']}, Close: {last_row['close']}")
        
        if buy_signal:
            return "BUY"
        elif sell_signal:
            return "SELL"
        return None

    def get_symbol_info(self):
        try:
            cmd = {
                "command": "getSymbol",
                "arguments": {
                    "symbol": self.symbol
                }
            }
            response = self.client.commandExecute(cmd["command"], cmd["arguments"])
            return response.get('returnData', {}) if response else {}
        except Exception as e:
            logging.error(f"‚ùå Erreur lors de la r√©cup√©ration des infos du symbole: {str(e)}")
            return {}

    def execute_trade(self, signal):
        if not signal or self.position_open:
            return

        symbol_info = self.get_symbol_info()
        if not symbol_info:
            logging.error("‚ùå Impossible d'obtenir les informations du symbole")
            return

        ask_price = float(symbol_info.get('ask', 0))
        bid_price = float(symbol_info.get('bid', 0))
        lot_min = float(symbol_info.get('lotMin', 0.01))
        
        if ask_price <= 0 or bid_price <= 0:
            logging.error("‚ùå Prix invalides re√ßus du serveur")
            return

        precision = len(str(symbol_info.get('pipsPrecision', 5)))
        pip_value = 1 / (10 ** precision)

        if signal == "BUY":
            entry_price = ask_price
            sl_price = entry_price * 0.99  # -1% pour SL
            tp_price = entry_price * 1.02  # +2% pour TP
        else:
            entry_price = bid_price
            sl_price = entry_price * 1.01  # +1% pour SL
            tp_price = entry_price * 0.98  # -2% pour TP

        #if signal == "BUY":
        #    entry_price = ask_price
        #    sl_price = round(entry_price - (100 * pip_value), precision)
        #    tp_price = round(entry_price + (200 * pip_value), precision)
        #else:
        #    entry_price = bid_price
        #    sl_price = round(entry_price + (100 * pip_value), precision)
        #    tp_price = round(entry_price - (200 * pip_value), precision)

        trade_cmd = {
            "command": "tradeTransaction",
            "arguments": {
                "tradeTransInfo": {
                    "cmd": 0 if signal == "BUY" else 1,
                    "symbol": self.symbol,
                    "volume": lot_min,
                    "type": 0,
                    "price": entry_price,
                    "sl": sl_price,
                    "tp": tp_price
                }
            }
        }

        response = self.client.commandExecute('tradeTransaction', trade_cmd['arguments'])
        if response.get('status'):
            self.current_order_id = response.get('returnData', {}).get('order', 0)
            self.position_open = True
            logging.info(f"‚úÖ Trade ex√©cut√©: {signal}, Order ID: {self.current_order_id}")
        else:
            logging.error(f"‚ùå √âchec de l'ex√©cution du trade: {response}")

    def check_trade_status(self):
        try:
            if not self.current_order_id:
                return False
            
            cmd = {
                "command": "getTrades",
                "arguments": {
                    "openedOnly": True
                }
            }
            response = self.client.commandExecute(cmd["command"], cmd["arguments"])
        
            if not response or 'returnData' not in response:
                return False
            
            trades = response['returnData']
            return any(trade.get('order2') == self.current_order_id for trade in trades)
        
        except Exception as e:
            logging.error(f"‚ùå Erreur lors de la v√©rification du trade: {str(e)}")
            return False

    def run_strategy(self):
        logging.info(f"ü§ñ D√©marrage du bot de trading sur {self.symbol}")
        
        while True:
            try:
                if self.position_open:
                    if not self.check_trade_status():
                        logging.info("üîÑ Position ferm√©e, recherche de nouvelles opportunit√©s...")
                        self.position_open = False
                        self.current_order_id = None

                df = self.get_historical_data()
                if df is not None:
                    df = self.calculate_indicators(df)
                    if df is not None:
                        signal = self.check_trading_signals(df)
                        if signal:
                            logging.info(f"üìä Signal d√©tect√©: {signal}")
                            self.execute_trade(signal)
                
                time.sleep(60)
                
            except Exception as e:
                logging.error(f"‚ùå Erreur dans la boucle de trading: {str(e)}")
                time.sleep(30)
                self.connect()

if __name__ == "__main__":
    while True:
        try:
            bot = XTBTradingBot(symbol='BITCOIN', timeframe='1h')
            if bot.connect():
                bot.run_strategy()
            else:
                logging.error("√âchec de connexion, nouvelle tentative dans 60 secondes...")
                time.sleep(60)
        except Exception as e:
            logging.error(f"Erreur critique: {str(e)}")
            time.sleep(60)